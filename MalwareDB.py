import streamlit as st
import pandas as pd
import requests
from datetime import datetime, timedelta
import sqlite3
import os
import json
import altair as alt
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import time

# List of months in English (global scope)
MONTHS_ENGLISH = [
    'January', 'February', 'March', 'April', 'May', 'June',
    'July', 'August', 'September', 'October', 'November', 'December'
]

# Funci√≥n para limpiar la base de datos
def limpiar_base_datos():
    conn = sqlite3.connect('malware_db.sqlite')
    cursor = conn.cursor()
    cursor.execute('DELETE FROM ataques')
    cursor.execute('DELETE FROM ultimas_puntuaciones')
    conn.commit()
    conn.close()

# Configuraci√≥n del sistema
st.sidebar.title("Configuration")

# Lista de sectores disponibles
SECTORES_DISPONIBLES = [
    "Business Services", "Technology", "Manufacturing", "Healthcare",
    "Transportation/Logistics", "Financial", "Government",
    "Agriculture and Food Production", "Energy", "Education",
    "Hospitality and Tourism", "Consumer Services", "Public Sector",
    "Financial Services", "Government Facilities", "Construction",
    "Information Technology", "Healthcare and Public Health",
    "Critical Manufacturing", "Transportation Systems", "Telecommunication",
    "Education Facilities", "Communication", "Commercial Facilities",
    "Food and Agriculture", "Emergency Services", "Retail",
    "Healthcare Services", "Wholesale & Retail", "Engineering",
    "Chemical", "Advertising, Marketing & Public Relations",
    "Energy & Utilities", "Internet & Telecommunication Services",
    "Defense Industrial Base", "Transportation",
    "Law Firms & Legal Services", "Automotive",
    "Community, Social Services & Non-Profit Organisations",
    "Agriculture", "Aerospace", "Food & Beverages", "Others",
    "Broadcasting", "Real Estate", "Water and Wastewater Systems",
    "Nuclear Reactors, Materials, and Waste", "IT Manufacturing",
    "Shipping & Logistics", "Legal", "Business Services, Technology"
]

# Widgets de configuraci√≥n
SECTOR_MONITORIZADO = st.sidebar.selectbox(
    "Select Industry to Monitor",
    SECTORES_DISPONIBLES,
    index=SECTORES_DISPONIBLES.index("Manufacturing")
)

PAIS_MONITORIZADO = st.sidebar.text_input(
    "Country Code to Monitor (e.g., DE, ES, US)",
    value="DE"
)

PUNTOS_SECTOR = st.sidebar.slider(
    "Points for Industry Attacks",
    min_value=1,
    max_value=5,
    value=3
)

PUNTOS_PAIS = st.sidebar.slider(
    "Points for Country Attacks",
    min_value=1,
    max_value=5,
    value=2
)

PUNTOS_RECIENTE = st.sidebar.slider(
    "Points for Recent Activity (last 30 days)",
    min_value=1,
    max_value=5,
    value=2
)

st.sidebar.title("Impact Config")

PUNTOS_IMPACTO_ALTO = st.sidebar.slider(
    "Points for High Impact (>100 victims)",
    min_value=1,
    max_value=5,
    value=3
)

PUNTOS_IMPACTO_MEDIO = st.sidebar.slider(
    "Points for Medium Impact (50-99 victims)",
    min_value=1,
    max_value=5,
    value=2
)

PUNTOS_IMPACTO_BAJO = st.sidebar.slider(
    "Points for Low Impact (<50 victims)",
    min_value=1,
    max_value=5,
    value=1
)

st.sidebar.title("Notification")

UMBRAL_NOTIFICACION = st.sidebar.slider(
    "Notification Threshold",
    min_value=1,
    max_value=10,
    value=9
)

# Bot√≥n para aplicar cambios
if st.sidebar.button("Apply Changes"):
    limpiar_base_datos()
    st.rerun()

# Crear la base de datos si no existe
def crear_base_datos():
    conn = sqlite3.connect('malware_db.sqlite')
    cursor = conn.cursor()
    
    # Crear tabla si no existe
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ataques (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        actor TEXT,
        sector TEXT,
        pais TEXT,
        fecha_ataque TEXT,
        puntuacion INTEGER,
        num_victimas INTEGER,
        fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # Crear tabla para las √∫ltimas puntuaciones
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS ultimas_puntuaciones (
        actor TEXT PRIMARY KEY,
        puntuacion REAL,
        fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    conn.commit()
    conn.close()

# Funci√≥n para obtener datos de Ransomware.live
def obtener_datos_ransomware_live(max_retries=3, timeout=30):
    url = "https://api.ransomware.live/v2/victims/2025"
    
    for attempt in range(max_retries):
        try:
            response = requests.get(url, timeout=timeout)
            if response.status_code == 200:
                datos = response.json()
                # Contar el n√∫mero de v√≠ctimas por grupo
                conteo_victimas = {}
                for entrada in datos:
                    grupo = entrada.get("group", "Desconocido")
                    conteo_victimas[grupo] = conteo_victimas.get(grupo, 0) + 1
                
                # A√±adir el conteo a cada entrada
                for entrada in datos:
                    grupo = entrada.get("group", "Desconocido")
                    entrada["num_victimas"] = conteo_victimas.get(grupo, 0)
                
                return datos
            elif response.status_code == 504:
                if attempt < max_retries - 1:
                    st.warning(f"Timeout al conectar con la API. Reintentando... (Intento {attempt + 1}/{max_retries})")
                    time.sleep(2)  # Esperar 2 segundos antes de reintentar
                    continue
                else:
                    st.error("No se pudo conectar con la API despu√©s de varios intentos. Por favor, int√©ntalo de nuevo m√°s tarde.")
                    return []
            else:
                st.error(f"Error al obtener datos de la API: {response.status_code}")
                return []
        except requests.exceptions.Timeout:
            if attempt < max_retries - 1:
                st.warning(f"Timeout al conectar con la API. Reintentando... (Intento {attempt + 1}/{max_retries})")
                time.sleep(2)
                continue
            else:
                st.error("No se pudo conectar con la API despu√©s de varios intentos. Por favor, int√©ntalo de nuevo m√°s tarde.")
                return []
        except Exception as e:
            st.error(f"Error de conexi√≥n: {str(e)}")
            return []
    
    return []

# Funci√≥n para calcular la puntuaci√≥n y obtener los factores
def calcular_puntuacion(actor, sector, pais, fecha_ataque, num_victimas):
    factores = []
    score = 0
    
    # Industry
    if sector and sector.lower() == SECTOR_MONITORIZADO.lower():
        score += PUNTOS_SECTOR
        factores.append(f"Has attacked {SECTOR_MONITORIZADO} industry")
    
    # Recent activity (last 3 months)
    try:
        try:
            fecha_ataque_dt = datetime.strptime(fecha_ataque.split('T')[0], "%Y-%m-%d")
        except ValueError:
            try:
                fecha_ataque_dt = datetime.strptime(fecha_ataque.split(' ')[0], "%Y-%m-%d")
            except ValueError:
                fecha_ataque_dt = datetime.now()
        
        if fecha_ataque_dt > datetime.now():
            fecha_ataque_dt = datetime.now()
        
        if fecha_ataque_dt >= datetime.now() - timedelta(days=90):
            score += PUNTOS_RECIENTE
            factores.append(f"Recent activity (last 3 months) [+{PUNTOS_RECIENTE} points]")
    except Exception as e:
        pass

    # Attacks in country
    if pais and pais.upper() == PAIS_MONITORIZADO:
        score += PUNTOS_PAIS
        factores.append(f"Has attacked victims in {PAIS_MONITORIZADO}")
    
    # Potential Impact based on number of victims
    if num_victimas >= 100:
        score += PUNTOS_IMPACTO_ALTO
        factores.append(f"High potential impact (>100 victims) [+{PUNTOS_IMPACTO_ALTO} points]")
    elif num_victimas >= 50:
        score += PUNTOS_IMPACTO_MEDIO
        factores.append(f"Medium potential impact (50-99 victims) [+{PUNTOS_IMPACTO_MEDIO} points]")
    elif num_victimas > 0:
        score += PUNTOS_IMPACTO_BAJO
        factores.append(f"Low potential impact (<50 victims) [+{PUNTOS_IMPACTO_BAJO} points]")
    
    return score, ", ".join(factores) if factores else "No specific factors"

# Funci√≥n para guardar datos en la base de datos
def guardar_en_db(actores):
    conn = sqlite3.connect('malware_db.sqlite')
    cursor = conn.cursor()
    
    # Limpiar la tabla antes de insertar nuevos datos
    cursor.execute('DELETE FROM ataques')
    
    for actor in actores:
        cursor.execute('''
        INSERT INTO ataques (actor, sector, pais, fecha_ataque, puntuacion, num_victimas)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            actor["Actor"],
            actor["Sector"],
            actor["Pais"],
            actor["Fecha de Ataque"],
            actor["Puntuacion"],
            actor["Num_Victimas"]
        ))
    
    conn.commit()
    conn.close()

# Funci√≥n para obtener datos de la base de datos
def obtener_de_db():
    conn = sqlite3.connect('malware_db.sqlite')
    df = pd.read_sql_query(f'''
    WITH actor_scores AS (
        SELECT 
            actor,
            MAX(CASE WHEN sector = '{SECTOR_MONITORIZADO}' AND fecha_ataque >= date('now', '-30 days') THEN {PUNTOS_SECTOR} ELSE 0 END) +
            MAX(CASE WHEN pais = '{PAIS_MONITORIZADO}' AND fecha_ataque >= date('now', '-30 days') THEN {PUNTOS_PAIS} ELSE 0 END) +
            MAX(CASE WHEN fecha_ataque >= date('now', '-30 days') THEN {PUNTOS_RECIENTE} ELSE 0 END) +
            CASE 
                WHEN MAX(num_victimas) >= 100 THEN 3
                WHEN MAX(num_victimas) >= 50 THEN 2
                WHEN MAX(num_victimas) > 0 THEN 1
                ELSE 0
            END as puntuacion_total,
            MAX(CASE WHEN sector = '{SECTOR_MONITORIZADO}' AND fecha_ataque >= date('now', '-30 days') THEN 1 ELSE 0 END) as tecnologia,
            MAX(CASE WHEN pais = '{PAIS_MONITORIZADO}' AND fecha_ataque >= date('now', '-30 days') THEN 1 ELSE 0 END) as alemania,
            MAX(CASE WHEN fecha_ataque >= date('now', '-30 days') THEN 1 ELSE 0 END) as reciente,
            MAX(num_victimas) as num_victimas
        FROM ataques
        WHERE fecha_ataque >= date('now', '-30 days')
        GROUP BY actor
    )
    SELECT 
        actor,
        puntuacion_total as puntuacion_promedio,
        tecnologia,
        alemania,
        reciente,
        num_victimas
    FROM actor_scores
    WHERE puntuacion_total > 0
    ORDER BY puntuacion_total DESC
    LIMIT 10
    ''', conn)
    conn.close()
    return df

# Funci√≥n para obtener los √∫ltimos 12 meses desde el mes actual
def obtener_meses_anteriores():
    mes_actual = datetime.now().month
    meses = []
    for i in range(12):
        mes = (mes_actual - i - 1) % 12
        if mes == 0:
            mes = 12
        meses.append(MONTHS_ENGLISH[mes - 1])
    return meses[::-1]  # Invertir para tener el orden correcto

# Funci√≥n para obtener datos mensuales
def obtener_datos_mensuales():
    conn = sqlite3.connect('malware_db.sqlite')
    
    # Obtener la lista de todos los actores
    actores = pd.read_sql_query('SELECT DISTINCT actor FROM ataques', conn)['actor'].tolist()
    
    # Obtener los √∫ltimos 12 meses desde el mes actual
    meses_anteriores = obtener_meses_anteriores()
    
    # Obtener los datos de los √∫ltimos 12 meses
    df = pd.read_sql_query(f'''
    SELECT 
        strftime('%Y-%m', fecha_ataque) as mes,
        actor,
        MAX(CASE WHEN sector = '{SECTOR_MONITORIZADO}' THEN {PUNTOS_SECTOR} ELSE 0 END) +
        MAX(CASE WHEN pais = '{PAIS_MONITORIZADO}' THEN {PUNTOS_PAIS} ELSE 0 END) +
        MAX(CASE WHEN fecha_ataque >= date('now', '-90 days') THEN {PUNTOS_RECIENTE} ELSE 0 END) as puntuacion
    FROM ataques
    WHERE fecha_ataque >= date('now', '-365 days')
    GROUP BY mes, actor
    ORDER BY mes, puntuacion DESC
    ''', conn)
    conn.close()
    
    # Convertir la columna mes a datetime y luego a string con el formato deseado
    df['mes'] = pd.to_datetime(df['mes'] + '-01').dt.strftime('%B')
    
    # Mapear los nombres de meses en ingl√©s a espa√±ol
    mes_map = {
        'January': 'Enero', 'February': 'Febrero', 'March': 'Marzo',
        'April': 'Abril', 'May': 'Mayo', 'June': 'Junio',
        'July': 'Julio', 'August': 'Agosto', 'September': 'Septiembre',
        'October': 'Octubre', 'November': 'Noviembre', 'December': 'Diciembre'
    }
    df['mes'] = df['mes'].map(mes_map)
    
    # Crear un DataFrame completo con todos los meses y actores
    df_completo = pd.DataFrame({
        'mes': meses_anteriores * len(actores),
        'actor': sorted(actores * 12)
    })
    
    # Merge con los datos existentes
    df_final = pd.merge(df_completo, df[['mes', 'actor', 'puntuacion']], 
                       on=['mes', 'actor'], how='left')
    
    # Rellenar NaN con 0
    df_final['puntuacion'] = df_final['puntuacion'].fillna(0)
    
    # Filtrar actores que han tenido puntuaci√≥n 0 en todos los meses
    actores_con_puntuacion = df_final.groupby('actor')['puntuacion'].sum()
    actores_con_puntuacion = actores_con_puntuacion[actores_con_puntuacion > 0].index.tolist()
    df_final = df_final[df_final['actor'].isin(actores_con_puntuacion)]
    
    # Asegurar que los meses est√©n en el orden correcto
    df_final['mes'] = pd.Categorical(df_final['mes'], categories=meses_anteriores, ordered=True)
    df_final = df_final.sort_values('mes')
    
    return df_final

# Funci√≥n para obtener informaci√≥n detallada de un grupo
def obtener_info_grupo(nombre_grupo):
    url = f"https://api.ransomware.live/v2/groups"
    try:
        response = requests.get(url)
        if response.status_code == 200:
            grupos = response.json()
            for grupo in grupos:
                if grupo['name'].lower() == nombre_grupo.lower():
                    return grupo
        return None
    except Exception as e:
        st.error(f"Error al obtener informaci√≥n del grupo: {str(e)}")
        return None

# Funci√≥n para obtener YARA rules
def obtener_yara_rules(nombre_grupo):
    # Lista de prefijos a probar
    prefixes = ['win.', 'osx.', 'elf.']
    
    for prefix in prefixes:
        try:
            # Construir la URL con el prefijo actual
            url = f"https://malpedia.caad.fkie.fraunhofer.de/api/get/yara/{prefix}{nombre_grupo.lower()}?format=json"
            response = requests.get(url)
            
            if response.status_code == 200:
                # Si encontramos reglas, las devolvemos
                return response.text.strip()
            
        except Exception as e:
            st.error(f"Error al obtener YARA rules con prefijo {prefix}: {str(e)}")
            continue
    
    # Si llegamos aqu√≠, no se encontraron reglas con ning√∫n prefijo
    return None

# Funci√≥n para obtener datos mensuales de 2025
def obtener_datos_mensuales_2025():
    conn = sqlite3.connect('malware_db.sqlite')
    
    # Obtener los datos de 2025
    df = pd.read_sql_query(f'''
    WITH actor_scores AS (
        SELECT 
            strftime('%Y-%m', fecha_ataque) as mes,
            actor,
            MAX(CASE WHEN sector = '{SECTOR_MONITORIZADO}' THEN {PUNTOS_SECTOR} ELSE 0 END) +
            MAX(CASE WHEN pais = '{PAIS_MONITORIZADO}' THEN {PUNTOS_PAIS} ELSE 0 END) +
            MAX(CASE WHEN fecha_ataque >= date('now', '-30 days') THEN {PUNTOS_RECIENTE} ELSE 0 END) +
            CASE 
                WHEN MAX(num_victimas) >= 100 THEN {PUNTOS_IMPACTO_ALTO}
                WHEN MAX(num_victimas) >= 50 THEN {PUNTOS_IMPACTO_MEDIO}
                WHEN MAX(num_victimas) > 0 THEN {PUNTOS_IMPACTO_BAJO}
                ELSE 0
            END as puntuacion,
            MAX(CASE WHEN sector = '{SECTOR_MONITORIZADO}' THEN 1 ELSE 0 END) as tecnologia,
            MAX(CASE WHEN pais = '{PAIS_MONITORIZADO}' THEN 1 ELSE 0 END) as alemania,
            MAX(CASE WHEN fecha_ataque >= date('now', '-30 days') THEN 1 ELSE 0 END) as reciente,
            MAX(num_victimas) as num_victimas
        FROM ataques
        WHERE strftime('%Y', fecha_ataque) = '2025'
        GROUP BY mes, actor
    ),
    actores_desde_enero AS (
        SELECT DISTINCT actor
        FROM actor_scores
        WHERE mes = '2025-01'
    )
    SELECT 
        mes,
        actor,
        puntuacion,
        tecnologia,
        alemania,
        reciente,
        num_victimas
    FROM actor_scores
    WHERE actor IN (SELECT actor FROM actores_desde_enero)
    ORDER BY mes, puntuacion DESC
    ''', conn)
    conn.close()
    
    if df.empty:
        return df
    
    # Convertir la columna mes a datetime y luego a string con el formato deseado
    df['mes'] = pd.to_datetime(df['mes'] + '-01').dt.strftime('%B')
    
    # Mapear los nombres de meses en ingl√©s a espa√±ol
    mes_map = {
        'January': 'Enero', 'February': 'Febrero', 'March': 'Marzo',
        'April': 'Abril', 'May': 'Mayo', 'June': 'Junio',
        'July': 'Julio', 'August': 'Agosto', 'September': 'Septiembre',
        'October': 'Octubre', 'November': 'Noviembre', 'December': 'Diciembre'
    }
    df['mes'] = df['mes'].map(mes_map)
    
    # Crear un DataFrame completo con todos los meses y actores
    meses_2025 = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 
                  'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre']
    actores_desde_enero = df['actor'].unique()
    
    # Crear listas para el DataFrame completo
    meses_lista = []
    actores_lista = []
    
    for actor in actores_desde_enero:
        for mes in meses_2025:
            meses_lista.append(mes)
            actores_lista.append(actor)
    
    # Crear el DataFrame completo
    df_completo = pd.DataFrame({
        'mes': meses_lista,
        'actor': actores_lista
    })
    
    # Asegurar que ambos DataFrames tengan el mismo tipo de datos para 'mes' y 'actor'
    df['mes'] = df['mes'].astype(str)
    df['actor'] = df['actor'].astype(str)
    df_completo['mes'] = df_completo['mes'].astype(str)
    df_completo['actor'] = df_completo['actor'].astype(str)
    
    # Merge con los datos existentes
    df_final = pd.merge(df_completo, df[['mes', 'actor', 'puntuacion', 'tecnologia', 'alemania', 'reciente', 'num_victimas']], 
                       on=['mes', 'actor'], how='left')
    
    # Rellenar NaN con 0
    df_final['puntuacion'] = df_final['puntuacion'].fillna(0)
    df_final['tecnologia'] = df_final['tecnologia'].fillna(0)
    df_final['alemania'] = df_final['alemania'].fillna(0)
    df_final['reciente'] = df_final['reciente'].fillna(0)
    df_final['num_victimas'] = df_final['num_victimas'].fillna(0)
    
    # Asegurar que los meses est√©n en el orden correcto
    df_final['mes'] = pd.Categorical(df_final['mes'], categories=meses_2025, ordered=True)
    df_final = df_final.sort_values('mes')
    
    return df_final

# Configuraci√≥n del correo electr√≥nico
#EMAIL_SENDER = "xxxxxxx@gmail.com"
#EMAIL_PASSWORD = "xxxx xxxx xxxx xxxx"  # Reemplazar con tu contrase√±a de aplicaci√≥n de Gmail
#EMAIL_RECIPIENT = "xxxxxxx@gmail.com"
#SMTP_SERVER = "smtp.gmail.com"
#SMTP_PORT = 587

def obtener_ultima_puntuacion(actor):
    conn = sqlite3.connect('malware_db.sqlite')
    cursor = conn.cursor()
    cursor.execute('SELECT puntuacion FROM ultimas_puntuaciones WHERE actor = ?', (actor,))
    resultado = cursor.fetchone()
    conn.close()
    return resultado[0] if resultado else None

def guardar_ultima_puntuacion(actor, puntuacion):
    conn = sqlite3.connect('malware_db.sqlite')
    cursor = conn.cursor()
    cursor.execute('''
    INSERT OR REPLACE INTO ultimas_puntuaciones (actor, puntuacion)
    VALUES (?, ?)
    ''', (actor, puntuacion))
    conn.commit()
    conn.close()

def enviar_notificacion_email(actor, puntuacion, factores):
    try:
        # Verificar si la puntuaci√≥n ha cambiado y es >= 9
        ultima_puntuacion = obtener_ultima_puntuacion(actor)
        if ultima_puntuacion is not None and ultima_puntuacion == puntuacion:
            return  # No enviar correo si la puntuaci√≥n no ha cambiado
        
        # Guardar la nueva puntuaci√≥n
        guardar_ultima_puntuacion(actor, puntuacion)
        
        # Solo enviar correo si la puntuaci√≥n es >= 9
        if puntuacion >= UMBRAL_NOTIFICACION:
            # Crear el mensaje
            msg = MIMEMultipart()
            msg['From'] = EMAIL_SENDER
            msg['To'] = EMAIL_RECIPIENT
            msg['Subject'] = f"‚ö†Ô∏è ALERT: {actor} has reached score of {puntuacion}/10"
            
            # Cuerpo del mensaje
            body = f"""
            It has been detected that the threat actor {actor} has reached a score of {puntuacion}/10.
            
            Factors contributing to the score:
                *{factores}
            
            It is recommended to review the activity of this threat actor
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            # Iniciar conexi√≥n con el servidor SMTP
            server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
            server.starttls()
            server.login(EMAIL_SENDER, EMAIL_PASSWORD)
            
            # Enviar correo
            text = msg.as_string()
            server.sendmail(EMAIL_SENDER, EMAIL_RECIPIENT, text)
            server.quit()
    except Exception as e:
        pass  # Silenciar cualquier error

# Crear la base de datos
crear_base_datos()

# Obtener datos de la API
datos = obtener_datos_ransomware_live()

# Procesar datos
actores = []
for entrada in datos:
    try:
        actor = entrada.get("group", "Desconocido")
        sector = entrada.get("activity", "Desconocido")
        pais = entrada.get("country", "Desconocido")
        fecha_ataque = entrada.get("attackdate", "2000-01-01")
        num_victimas = entrada.get("num_victimas", 0)
        
        # Convertir fecha para filtrar
        try:
            try:
                fecha_ataque_dt = datetime.strptime(fecha_ataque.split('T')[0], "%Y-%m-%d")
            except ValueError:
                try:
                    fecha_ataque_dt = datetime.strptime(fecha_ataque.split(' ')[0], "%Y-%m-%d")
                except ValueError:
                    fecha_ataque_dt = datetime.now()
            
            if fecha_ataque_dt > datetime.now():
                fecha_ataque_dt = datetime.now()
            
            # Guardar todos los datos de 2025
            score, factores = calcular_puntuacion(actor, sector, pais, fecha_ataque, num_victimas)
            actores.append({
                "Actor": actor,
                "Sector": sector,
                "Pais": pais,
                "Fecha de Ataque": fecha_ataque_dt.strftime("%Y-%m-%d"),
                "Puntuacion": score,
                "Factores": factores,
                "Num_Victimas": num_victimas
            })
        except Exception as e:
            continue
    except Exception as e:
        continue

# Limpiar y guardar datos en la base de datos
limpiar_base_datos()
guardar_en_db(actores)

# Visualization with Streamlit
st.title("Ransomware Database")
st.write("Analysis of the most relevant threat actors according to their risk score.")


# Obtener datos de la base de datos
df_ataques = obtener_de_db()

if not df_ataques.empty:
    # Create a new DataFrame with only the necessary columns
    df_simple = df_ataques[['actor', 'puntuacion_promedio', 'tecnologia', 'alemania', 'reciente', 'num_victimas']].copy()
    df_simple.columns = ['Threat Actor', 'Risk Score', f'Has attacked {SECTOR_MONITORIZADO} industry', f'Has attacked victims in {PAIS_MONITORIZADO}', 'Recent activity (last 30 days)', 'Number of Victims']
    
    # Format the score to be out of 10
    df_simple['Risk Score'] = df_simple['Risk Score'].round(1)
    
    # Convert 1/0 to checkmarks
    df_simple[f'Has attacked {SECTOR_MONITORIZADO} industry'] = df_simple[f'Has attacked {SECTOR_MONITORIZADO} industry'].map({1: '‚úì', 0: ''})
    df_simple[f'Has attacked victims in {PAIS_MONITORIZADO}'] = df_simple[f'Has attacked victims in {PAIS_MONITORIZADO}'].map({1: '‚úì', 0: ''})
    df_simple['Recent activity (last 30 days)'] = df_simple['Recent activity (last 30 days)'].map({1: '‚úì', 0: ''})
    
    # Check for threat actors with score >= NOTIFICATION_THRESHOLD
    for index, row in df_simple.iterrows():
        if row['Risk Score'] >= UMBRAL_NOTIFICACION:
            factores = []
            if row[f'Has attacked {SECTOR_MONITORIZADO} industry'] == '‚úì':
                factores.append(f"Has attacked {SECTOR_MONITORIZADO} industry")
            if row[f'Has attacked victims in {PAIS_MONITORIZADO}'] == '‚úì':
                factores.append(f"Has attacked victims in {PAIS_MONITORIZADO}")
            if row['Recent activity (last 30 days)'] == '‚úì':
                factores.append("Recent activity (last 30 days)")
            if row['Number of Victims'] >= 100:
                factores.append("High potential impact (>100 victims)")
            elif row['Number of Victims'] >= 50:
                factores.append("Medium potential impact (50-99 victims)")
            elif row['Number of Victims'] > 0:
                factores.append("Low potential impact (<50 victims)")
            
            enviar_notificacion_email(row['Threat Actor'], row['Risk Score'], "\n".join(factores))
    
    # Show the table
    st.dataframe(
        df_simple,
        column_config={
            "Threat Actor": st.column_config.TextColumn(
                "Threat Actor",
                width="medium",
            ),
            "Risk Score": st.column_config.ProgressColumn(
                "Risk Score",
                help="Risk score out of 10",
                format="%.1f",
                min_value=0,
                max_value=10,
            ),
            f'Has attacked {SECTOR_MONITORIZADO} industry': st.column_config.TextColumn(
                f'Has attacked {SECTOR_MONITORIZADO} industry',
                width="medium",
            ),
            f'Has attacked victims in {PAIS_MONITORIZADO}': st.column_config.TextColumn(
                f'Has attacked victims in {PAIS_MONITORIZADO}',
                width="medium",
            ),
            "Recent activity (last 30 days)": st.column_config.TextColumn(
                "Recent activity (last 30 days)",
                width="medium",
            ),
            "Number of Victims": st.column_config.NumberColumn(
                "Number of Victims",
                format="%d",
            ),
        },
        hide_index=True,
    )
    
    # Show score evolution chart for 2025
    st.markdown("### üìà Score Evolution (2025)")
    df_mensual = obtener_datos_mensuales_2025()
    
    if not df_mensual.empty:
        # Get list of all available actors
        actores_disponibles = df_mensual['actor'].unique().tolist()
        
        # Add actor selector
        actores_seleccionados = st.multiselect(
            'Select ransomware groups to display:',
            actores_disponibles,
            default=actores_disponibles[:5] if len(actores_disponibles) > 5 else actores_disponibles,
            help='You can select multiple groups to compare their evolution'
        )
        
        # Filter data according to selection
        df_filtrado = df_mensual[df_mensual['actor'].isin(actores_seleccionados)]
        
        if not df_filtrado.empty:
            # Create a new DataFrame with the necessary data
            df_grafico = df_filtrado.copy()
            
            # Convert numeric columns to float and ensure no NaN values
            columnas_numericas = ['puntuacion', 'tecnologia', 'alemania', 'reciente']
            for col in columnas_numericas:
                df_grafico[col] = pd.to_numeric(df_grafico[col], errors='coerce').fillna(0)
            
            # Create the chart with Altair
            chart = alt.Chart(df_grafico).mark_line(point=True).encode(
                x=alt.X('mes:N', title='Month', sort=MONTHS_ENGLISH),
                y=alt.Y('puntuacion:Q', title='Score', scale=alt.Scale(domain=[0, 10])),
                color=alt.Color('actor:N', legend=alt.Legend(title="Ransomware Group")),
                tooltip=[
                    alt.Tooltip('mes:N', title='Month'),
                    alt.Tooltip('actor:N', title='Group'),
                    alt.Tooltip('puntuacion:Q', title='Total Score', format='.1f'),
                    alt.Tooltip('tecnologia:Q', title=f'{SECTOR_MONITORIZADO} Industry', format='.0f'),
                    alt.Tooltip('alemania:Q', title=f'{PAIS_MONITORIZADO} Victims', format='.0f'),
                    alt.Tooltip('reciente:Q', title='Recent', format='.0f'),
                    alt.Tooltip('num_victimas:Q', title='Number of Victims', format='.0f')
                ]
            ).properties(
                height=500,
                width='container'
            )
            
            # Show the chart
            st.altair_chart(chart, use_container_width=True)
            
            # Add additional information
            st.markdown("""
            <div style='margin-top: 10px; font-size: 0.9em; color: #666;'>
            ‚ÑπÔ∏è This chart shows the score evolution of selected ransomware groups during 2025.
            </div>
            """, unsafe_allow_html=True)
        else:
            st.warning("Please select at least one ransomware group to display in the chart.")
    else:
        st.info("Not enough data to show monthly evolution for 2025.")
    
    # Show details of threat actors with score >= 7
    st.markdown("### Critical Threat Actors Details")
    for index, row in df_simple.iterrows():
        if row['Risk Score'] >= 7:
            with st.expander(f"üîç View details of {row['Threat Actor']} (Score: {row['Risk Score']})"):
                info_grupo = obtener_info_grupo(row['Threat Actor'])
                if info_grupo:
                    # Add download button
                    contenido_txt = f"Detailed information of {row['Threat Actor']}\n"
                    contenido_txt += "=" * 50 + "\n\n"
                    
                    # Description
                    if info_grupo.get('description'):
                        contenido_txt += "DESCRIPTION:\n"
                        contenido_txt += info_grupo['description'].replace('<br>', '\n') + "\n\n"
                    
                    # TTPs
                    if info_grupo.get('ttps'):
                        contenido_txt += "TECHNIQUES, TACTICS AND PROCEDURES:\n"
                        for tactic in info_grupo['ttps']:
                            contenido_txt += f"\n{tactic['tactic_name']}:\n"
                            for technique in tactic['techniques']:
                                contenido_txt += f"- {technique['technique_name']} ({technique['technique_id']})\n"
                        contenido_txt += "\n"
                    
                    # Tools
                    if info_grupo.get('tools'):
                        contenido_txt += "TOOLS USED:\n"
                        for categoria, herramientas in info_grupo['tools'][0].items():
                            if herramientas:
                                contenido_txt += f"\n{categoria}:\n"
                                for herramienta in herramientas:
                                    contenido_txt += f"- {herramienta}\n"
                        contenido_txt += "\n"
                    
                    # URLs
                    if info_grupo.get('locations'):
                        contenido_txt += "RELATED URLs:\n"
                        for location in info_grupo['locations']:
                            contenido_txt += f"\n{location['title']}:\n"
                            contenido_txt += f"{location['fqdn']}\n"
                            if location.get('available') is not None:
                                estado = "Available" if location['available'] else "Not available"
                                contenido_txt += f"Status: {estado}\n"
                    
                    # Add YARA rules to TXT file
                    yara_rule = obtener_yara_rules(row['Threat Actor'])
                    if yara_rule:
                        contenido_txt += "\nYARA RULES:\n"
                        contenido_txt += "=" * 50 + "\n"
                        contenido_txt += yara_rule + "\n"
                    
                    # Download button
                    st.download_button(
                        label="üì• Download details as TXT",
                        data=contenido_txt,
                        file_name=f"{row['Threat Actor'].lower().replace(' ', '_')}_details.txt",
                        mime="text/plain"
                    )
                    
                    st.subheader(f"Detailed information of {row['Threat Actor']}")
                    
                    # Show description if exists
                    if info_grupo.get('description'):
                        st.markdown("### üìù Description")
                        descripcion = info_grupo['description'].replace('<br>', '\n\n')
                        st.markdown(descripcion)
                    
                    # Show TTPs if exist
                    if info_grupo.get('ttps'):
                        st.markdown("### üéØ Techniques, Tactics and Procedures")
                        for tactic in info_grupo['ttps']:
                            st.markdown(f"#### {tactic['tactic_name']}")
                            for technique in tactic['techniques']:
                                st.markdown(f"- **{technique['technique_name']}** ({technique['technique_id']})")
                    
                    # Show tools if exist
                    if info_grupo.get('tools'):
                        st.markdown("### üõ†Ô∏è Tools used")
                        for categoria, herramientas in info_grupo['tools'][0].items():
                            if herramientas:
                                st.markdown(f"#### {categoria}")
                                for herramienta in herramientas:
                                    st.markdown(f"- {herramienta}")
                    
                    # Show URLs if exist
                    if info_grupo.get('locations'):
                        st.markdown("### üåê Related URLs")
                        for location in info_grupo['locations']:
                            st.markdown(f"- **{location['title']}**")
                            st.code(location['fqdn'])
                            if location.get('available') is not None:
                                estado = "‚úÖ Available" if location['available'] else "‚ùå Not available"
                                st.markdown(f"  *Status: {estado}*")
                    
                    # Show YARA rules if exist
                    st.markdown("### üõ°Ô∏è YARA Rules")
                    if yara_rule:
                        # Add CSS style to improve visualization
                        st.markdown("""
                        <style>
                        .yara-code {
                            background-color: #f8f9fa;
                            border-radius: 5px;
                            padding: 15px;
                            font-family: 'Courier New', monospace;
                            white-space: pre-wrap;
                            margin: 10px 0;
                        }
                        </style>
                        """, unsafe_allow_html=True)
                        
                        # Show the rule with formatting
                        st.code(yara_rule, language='yara')
                    else:
                        st.info("No YARA rules found for this threat actor.")
                else:
                    st.warning(f"No detailed information found for {row['Threat Actor']}")
else:
    st.warning("No attack data found in the last year.")
